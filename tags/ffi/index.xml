<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ffi on bheisler.github.io</title>
    <link>https://bheisler.github.io/tags/ffi/index.xml</link>
    <description>Recent content in Ffi on bheisler.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://bheisler.github.io/tags/ffi/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Calling Rust From Python</title>
      <link>https://bheisler.github.io/post/calling-rust-in-python/</link>
      <pubDate>Sun, 02 Apr 2017 00:00:00 -0600</pubDate>
      
      <guid>https://bheisler.github.io/post/calling-rust-in-python/</guid>
      <description>

&lt;p&gt;Hello! This is a detailed example of exposing Rust code to other languages (in
this case, Python). Most articles I&amp;rsquo;ve seen that cover this topic uses really
trivial example functions, skipping over a lot of the complexity. Even the better
ones out there typically don&amp;rsquo;t have a pre-existing, reasonably complex program
to work with. I&amp;rsquo;m going to start with trivial functions and build my way up to
being able to define a scene for my &lt;a href=&#34;https://github.com/bheisler/raytracer&#34;&gt;raytracer&lt;/a&gt;
in Python using a series of calls to Rust, then render it and return the
resulting image data back to Python. If you want to know more about the raytracer,
I wrote a series of posts on it &lt;a href=&#34;https://bheisler.github.io/post/writing-raytracer-in-rust-part-1/&#34;&gt;here&lt;/a&gt;,
but it won&amp;rsquo;t be necessary; I&amp;rsquo;ll explain parts of the raytracer here as we need
them. Hopefully this will give a more complete picture of how to incorporate
complex Rust code into Python.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve never written any sort of Python/C interop before, so this should be another
learning experience all around. I&amp;rsquo;m going to arbitrarily choose
&lt;a href=&#34;https://cffi.readthedocs.io/en/latest/&#34;&gt;CFFI&lt;/a&gt; as the Python interop library.
It&amp;rsquo;s portable across interpreters and seems nicer to use than &lt;a href=&#34;https://docs.python.org/2/library/ctypes.html&#34;&gt;ctypes&lt;/a&gt;.
I expect the main concepts will be broadly applicable to other libraries (and
other languages such as Ruby). Let get started!&lt;/p&gt;

&lt;h2 id=&#34;calling-functions&#34;&gt;Calling Functions&lt;/h2&gt;

&lt;p&gt;The first thing to do is to define a Rust function we want to call from Python.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/effc8c457c9d85d1e318be52e1b8c98d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;We&amp;rsquo;re actually defining a function for Rust&amp;rsquo;s C foreign-function interface. The
basic idea here is that we write a wrapper in Python that knows how to call
C functions, and a wrapper in Rust that exposes C functions and translates them
to regular function calls in Rust. It&amp;rsquo;s sort of like we&amp;rsquo;re calling from Python
into C into Rust. The &lt;code&gt;no_mangle&lt;/code&gt; attribute and &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; above instruct rustc
not to change the name of the function (otherwise CFFI wouldn&amp;rsquo;t be able to
find it later) and to emit a function that can be called as if it were written
in C. We&amp;rsquo;ll need both for all functions that we want to expose to C.&lt;/p&gt;

&lt;p&gt;Now we need to instruct Cargo to build this library as a dynamic library
(&amp;ldquo;dylib&amp;rdquo; in Cargo terms). I&amp;rsquo;m writing this on a Windows PC, so Cargo
produces a &lt;code&gt;raytracer_ffi.dll&lt;/code&gt; file. I tested it on Linux as well and it created
&lt;code&gt;libraytracer_ffi.so&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/06c25b67a35bfd8f5b38781256558230.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Then we need some Python code to load and call this shared library:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/ec798db12cd69153a6330e67eb6d3dac.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Let&amp;rsquo;s break this down a bit. First we import the &lt;code&gt;cffi&lt;/code&gt; module and create an
FFI object. Then we call &lt;code&gt;cdef&lt;/code&gt; and pass it some text - this text is a C function
signature matching the &lt;code&gt;double&lt;/code&gt; function in Rust. CFFI parses this function
signature in order to determine how to call the function. We&amp;rsquo;ll need to do this
for all of the functions and structs we want to expose to Python. Then we open
the DLL file with &lt;code&gt;dlopen&lt;/code&gt;. Finally, we call the &lt;code&gt;double&lt;/code&gt; function as if it were
a regular Python function and print the result.&lt;/p&gt;

&lt;p&gt;And now we should be able to call &lt;code&gt;double&lt;/code&gt; from Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe test.py
18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Side note: I wasn&amp;rsquo;t able to get this working with PyPy on 64-bit Windows. I
didn&amp;rsquo;t find out why, but I assume it has something to do with how PyPy only
provides 32-bit binaries. PyPy worked fine for me on Linux, but I had to use
64-bit CPython on Windows.&lt;/p&gt;

&lt;h2 id=&#34;passing-structures&#34;&gt;Passing Structures&lt;/h2&gt;

&lt;p&gt;Now, if I&amp;rsquo;m going to be able to define a scene in Python, I&amp;rsquo;ll need to be able
to call functions and pass in structs as arguments. I&amp;rsquo;ll keep working with this
toy program a bit longer, but instead of simply doubling an integer, let&amp;rsquo;s try
and get it to calculate the length of a vector using &lt;code&gt;vector::Vector3::length&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, I&amp;rsquo;ll need to tell rustc that Vector3 should be laid out like a C struct.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/23de3e8f86143ceea2240b2a283b8f91.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;It appears that CFFI doesn&amp;rsquo;t have any way to call functions with stack-allocated
structures. Using the stack for small, copyable structures like Vector3 is
pretty common in Rust, but I guess it isn&amp;rsquo;t in C? So instead, our Rust function
will have to accept a pointer to a Vector3.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/f02545b55a01f5602f9aa8802c970847.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Here we define an extern function which accepts a raw pointer to a Vector3.
Dereferencing raw pointers is unsafe, so we use an unsafe block to convert the
raw pointer to a Rust reference. Finally, we call &lt;code&gt;length()&lt;/code&gt; and return the value.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/d7c3c411f6826303a8a09868821b6829.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Back in Python-land, we define a structure type matching Vector3 and the
signature of the length function. Now we need to allocate a new vector_t object,
which is done with the &lt;code&gt;ffi.new()&lt;/code&gt; function. We need to pay attention to
ownership here - the memory for the vector_t is allocated by Python and it will
have to be freed by Python. In this case, it will be freed when the vector object
gets garbage collected so we don&amp;rsquo;t need to worry about it, but we&amp;rsquo;ll need to
be more careful about ownership later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe test.py
1.73205080757
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;returning-references-back-to-python&#34;&gt;Returning References Back To Python&lt;/h2&gt;

&lt;p&gt;Now we&amp;rsquo;ll start the process of building our actual FFI code. We&amp;rsquo;ll start with the
Scene structure. I don&amp;rsquo;t especially want to expose all the complexity of the
Scene structure to Python, so instead we&amp;rsquo;ll use another C idiom and return an
opaque pointer.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/9a552f490d320410b28ab5e6c065ee9f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Notice that we use &lt;code&gt;Box::new&lt;/code&gt; to heap-allocate the structure, and &lt;code&gt;Box::into_raw&lt;/code&gt;
to convert it into a raw pointer to return. The corresponding Python code is:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/fcdb3bc11c85147172e1a6ec42f224d0.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I&amp;rsquo;m not actually sure &lt;code&gt;void*&lt;/code&gt; is the right way to go here, but I don&amp;rsquo;t know any
other way to do opaque pointers in this situation. If you know more about this,
let me know. CFFI seems to understand &lt;code&gt;uint32_t&lt;/code&gt; all on its own, and presumably
will call the Rust function with the appropriate integer width.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe raytracer.py
From Rust: Scene { width: 800, height: 600, fov: 45, elements: [],
    lights: [], shadow_bias: 0.0000000000001, max_recursion_depth: 10 }
From Python: &amp;lt;cdata &#39;void*&#39; 0x000000000155B260&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sharp readers might have noticed that we&amp;rsquo;re leaking Scene objects - we&amp;rsquo;re
allocating some memory on the heap for the boxed Scene and never freeing it.
For this trivial example, it doesn&amp;rsquo;t matter much because it will be cleaned
up when the process terminates, but it is rather inelegant, so let&amp;rsquo;s fix that.&lt;/p&gt;

&lt;h2 id=&#34;disposing-of-allocated-objects&#34;&gt;Disposing Of Allocated Objects&lt;/h2&gt;

&lt;p&gt;This goes back to the brief discussion of ownership earlier. Previously,
Python owned the allocated Vector3 object, so we could trust that it would be
safely freed when it was garbage-collected. Now, we have an object allocated by
Rust, but owned by a pointer in Python. Python doesn&amp;rsquo;t know how to deallocate
an object owned by Rust, so we&amp;rsquo;ll have to return ownership of the pointer to
Rust and allow Rust to free the memory.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/2f98fb5590e4dcd895773b1dd39a100d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Freeing the memory is actually quite simple - we use &lt;code&gt;Box::from_raw&lt;/code&gt; to convert
the raw pointer back into a box, and then just let it fall out of scope. Rust
will automatically clean everything up for us.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/51656ea2be9b8d0c2e7ba2c6ba77bfe4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Right now, there&amp;rsquo;s nothing to stop us from freeing the scene more than once,
or continuing to use that pointer after the scene has been freed. There&amp;rsquo;s nothing
we can do about that from the Rust side, but in Python we can at least build a
safe wrapper to work with.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/ba18f7b5c73c66ad9d1924e80881fc9e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Here, we define a Python class to represent our Scene. It defines the &lt;code&gt;__enter__&lt;/code&gt;
and &lt;code&gt;__exit__&lt;/code&gt; methods necessary to act as a &lt;a href=&#34;https://www.python.org/dev/peps/pep-0343/&#34;&gt;Context Manager&lt;/a&gt;,
which allows us to use it with the &lt;code&gt;with&lt;/code&gt; statement at the end. Running this
file confirms that the scene object is being freed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe raytracer.py
Freeing the scene
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enums&#34;&gt;Enums&lt;/h2&gt;

&lt;p&gt;Before we begin constructing our scene in Python, however, there&amp;rsquo;s one more bit
of complexity to tackle first. Every object in this raytracer contains a Material
structure to define what color the surface is, whether it&amp;rsquo;s reflective or
transparent, etc. This is defined in Rust using some enums and a struct:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/5af67a2bc9fb63ad1c77e087d5857c91.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Rust&amp;rsquo;s enums have no equivalent in C, and even if they did that DynamicImage
type certainly doesn&amp;rsquo;t. We&amp;rsquo;ll have to create C-compatible wrappers for these
types that we can expose to Python. I&amp;rsquo;ll focus on the Coloration enum for now,
the SurfaceType enum will work the same way.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by defining another enum:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/153001fea515624f8eaaf807640c79bb.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I know, I just said we can&amp;rsquo;t do enums in C. Instead, we&amp;rsquo;ll define a couple of
functions to create CColoration values on the heap and return opaque pointers
to them like we did with the Scene.&lt;/p&gt;

&lt;p&gt;First, the simple case of a solid color:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/37004afc200aa009204031f1443a2ad9.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Then, the more complex case of a path to a texture file.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/8fc77676d46de395b661c89bb0f5384d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Here we take a pointer to a null-terminated character array (a C-style string)
and convert it to a Rust string, which has a length and is encoded in UTF-8.
This conversion could fail, if the C string isn&amp;rsquo;t valid UTF-8. Notice that we
need to be very careful not to panic. We can&amp;rsquo;t just unwrap the result of
converting the CStr to a regular string, because panicking across FFI boundaries
is undefined behavior. Instead, we return a null pointer on all error
conditions. A more serious project would probably want to have more robust error
handling, but this is sufficient for now.&lt;/p&gt;

&lt;p&gt;The corresponding Python should be relatively familiar by now:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/02f53a18cc343e57b3a6e9b0c31678a4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The SurfaceType enum works basically the same way as above, so I&amp;rsquo;ll spare you
the details.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/fbfb35e8b010c89e7b40cc5b93b65a2c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;All those with&amp;rsquo;s are kind of ugly, but that&amp;rsquo;s the price we pay for safety.
We can verify that everything is being freed as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe raytracer.py
Freeing surface type
Freeing surface type
Freeing surface type
Freeing coloration
Freeing coloration
Freeing coloration
Freeing coloration
Freeing coloration
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;constructing-the-scene&#34;&gt;Constructing the Scene&lt;/h2&gt;

&lt;p&gt;Finally, we&amp;rsquo;re ready to start constructing the scene. I&amp;rsquo;ll focus on the case of
adding a Sphere to the scene. The code to define other objects is pretty much
the same.&lt;/p&gt;

&lt;p&gt;First, we need a new struct to represent Material:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/b90e0a5de2bdbc16d0120142bf6b94ba.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;And a function to add a sphere to a scene:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/bede2aa436be20ede3c7c876f2f28488.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Most of this is the now-familiar C foreign-function boilerplate. The
&lt;code&gt;material.to_rust()&lt;/code&gt; method works pretty much as you&amp;rsquo;d expect - it
constructs a Material value from a CMaterial value, potentially loading the
texture contained in the &lt;code&gt;CColoration&lt;/code&gt;. More noteworthy is the way we convert
the scene Box back into a raw pointer at the end of the method. This prevents
Rust from deallocating our scene.&lt;/p&gt;

&lt;p&gt;You might reasonably ask why I chose to have one function that creates and adds
the sphere directly to the scene. This does, after all, make it impossible for
me to return a Sphere to Python. The answer is that since I don&amp;rsquo;t really want to
manipulate Spheres in Python, there&amp;rsquo;s not much point in going to all that extra
effort. You can go ahead and do that if you like.&lt;/p&gt;

&lt;p&gt;Now that we have all of that, we can call it from Python as before:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/690a6cc77c1e3ba295f5ce45798b6f26.js&#34;&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;$ python.exe raytracer.py
Sphere { center: Point { x: 0, y: 0, z: -5 }, radius: 1, material:
  Material { coloration: Texture, albedo: 0.18, surface:
  Reflective { reflectivity: 0.7 } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rendering-and-returning-the-image-to-python&#34;&gt;Rendering and Returning the Image To Python&lt;/h2&gt;

&lt;p&gt;Now that we can define a scene in Python, we need a way to render it and return
the resulting image. We can&amp;rsquo;t just return a byte array, because Python can&amp;rsquo;t
handle stack-allocated objects, and anyway it would overflow the stack. We could
return a pointer/length pair, but then we have to pass it back to Rust to free
it. Instead, we&amp;rsquo;ll follow the C convention and have the caller provide a buffer
to render the image into.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/5c3983559358ef40d4de64d83a44cf61.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;After the usual boilerplate, we convert the C-style byte array into a mutable
slice with the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function, then wrap that into an
ImageBuffer and pass it to the raytracer for rendering. Slices in Rust don&amp;rsquo;t
own their contents, so we don&amp;rsquo;t need to do anything special to prevent Rust from
trying to free the buffer.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/bheisler/51eb8b1f5ad6067942d8a1a969842185.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;In Python, we need to save the dimensions of the image so that we can allocate
an appropriate buffer. The raytracer uses 4-byte RGBA pixels, so we calculate
the buffer size as 4 * width * height, allocate an appropriate buffer, and
render the image into it. Then we call &lt;code&gt;ffi.buffer&lt;/code&gt; to wrap it into a convenient
Python object. Finally, we pass that to the Pillow library to be wrapped into
an Image object that we can save out to disk or do further processing on.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/a/knyif&#34;&gt;&lt;img src=&#34;https://bheisler.github.io/static/rendered-by-python.png&#34; alt=&#34;Rendered By Python&#34; /&gt;&lt;/a&gt;
Click to see high-resolution image&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Overall, this turned out to be easier than I&amp;rsquo;d expected. CFFI&amp;rsquo;s user-friendly
interface helped a lot, I think, though the Rust side has a lot of boilerplate.
I expect some macros or something could help with that. I&amp;rsquo;d like to thank Jake
Goulding and co. for the &lt;a href=&#34;http://jakegoulding.com/rust-ffi-omnibus/slice_arguments/&#34;&gt;Rust FFI Omnibus&lt;/a&gt;,
which covers all of the basic techniques listed above (and provides examples
for a number of other languages, if you&amp;rsquo;d like to compare).&lt;/p&gt;

&lt;p&gt;As usual, if you want to try playing around with the code yourself, you can
check out the &lt;a href=&#34;https://github.com/bheisler/raytracer&#34;&gt;GitHub Repository&lt;/a&gt;. If you
do, though, be careful with the complexity of the scene you try to render. It&amp;rsquo;s
very easy to reach multi-hour rendering times when you&amp;rsquo;re defining scenes
programmatically. Otherwise, enjoy!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>